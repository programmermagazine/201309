<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="../css/pmag.css" type="text/css" />
</head>
<body>
<div id="header_wrap">
   <h1><a href="https://www.facebook.com/groups/programmerMagazine">程式人雜誌</a> <sub> --  <a href="https://dl.dropbox.com/u/101584453/pmag/201309/htm/home.html">2013 年 9 月號</a> (開放公益出版品)</sub></h1>
</div>
<div id="content">
<div id="TOC">
<ul>
<li><a href="#開放電腦計畫-3-vm0-虛擬機使用-javascriptnode.js-實作-作者陳鍾誠">開放電腦計畫 (3) – VM0 虛擬機：使用 JavaScript+Node.js 實作 (作者：陳鍾誠)</a></li>
</ul>
</div>
<h2 id="開放電腦計畫-3-vm0-虛擬機使用-javascriptnode.js-實作-作者陳鍾誠"><a href="#開放電腦計畫-3-vm0-虛擬機使用-javascriptnode.js-實作-作者陳鍾誠">開放電腦計畫 (3) – VM0 虛擬機：使用 JavaScript+Node.js 實作 (作者：陳鍾誠)</a></h2>
<p>在前幾期中，我們介紹了 CPU0 處理器的指令集，以及組譯器的實作方式，文章網址如下：</p>
<ul>
<li><a href="https://dl.dropboxusercontent.com/u/101584453/pmag/201306/htm/article5.html">開放電腦計畫 (1) – 整體架構與 CPU0 處理器</a></li>
<li><a href="http://programmermagazine.github.io/201307/htm/article5.html">開放電腦計畫 (2) – AS0 組譯器：使用 JavaScript+Node.js 實作</a></li>
</ul>
<p>在本文中，我們將接續前兩篇的內容，然後將焦點放在虛擬機 VM0 的實作上，說明一個最簡易的虛擬機是如何設計出來的。</p>
<h3 id="組譯範例"><a href="#組譯範例">組譯範例</a></h3>
<p>首先、讓讀者回顧一下，在上一篇文章中，我們設計了一個組譯器，可以組譯像以下的組合語言程式。</p>
<p>組合語言：<a href="https://dl.dropboxusercontent.com/u/101584453/pmag/201309/code/oc/sum.as0">sum.as0</a></p>
<pre><code>        LD     R1, sum      ; R1 = sum = 0
        LD     R2, i        ; R2 = i = 1
        LDI    R3, 10       ; R3 = 10
FOR:    CMP    R2, R3       ; if (R2 &gt; R3)
        JGT    EXIT         ;   goto EXIT
        ADD    R1, R1, R2   ; R1 = R1 + R2 (sum = sum + i)
        ADDI   R2, R2, 1    ; R2 = R2 + 1  ( i  = i + 1)
        JMP    FOR          ; goto FOR
EXIT:   ST     R1, sum      ; sum = R1
        ST     R2, i        ; i = R2
        LD     R9, msgptr   ; R9= pointer(msg) = &amp;msg
        SWI    3            ; SWI 3 : 印出 R9 (=&amp;msg) 中的字串
        MOV    R9, R1       ; R9 = R1 = sum
        SWI    4            ; SWI 2 : 印出 R9 (=R1=sum) 中的整數
        RET                 ; return 返回上一層呼叫函數
i:      RESW   1            ; int i
sum:    WORD   0            ; int sum=0
msg:    BYTE   &quot;1+...+10=&quot;, 0   ; char *msg = &quot;sum=&quot;
msgptr: WORD   msg          ; char &amp;msgptr = &amp;msg</code></pre>
<p>我們可以用 AS0 組譯器對這樣的 CPU0 組合語言進行組譯，以下是組譯過程與結果，會輸出機器碼到目的檔中。</p>
<pre><code>D:\Dropbox\Public\oc\code&gt;node as0 sum.as0 sum.ob0
...
...
=================SAVE OBJ FILE================

00 :  001F003C 002F0034 0830000A 10230000
10 :  2300000C 13112000 1B220001 26FFFFEC
20 :  011F001C 012F0014 009F001D 2A000003
30 :  12910000 2A000002 2C000000 00000000
40 :  00000000 73756D3D 00000000 44</code></pre>
<p>接著、我們就可以用虛擬機 VM0 來執行這個目的檔，我們可以選擇用預設不傾印的方式，得到以下的簡要執行結果。</p>
<p>虛擬機執行過程 (不傾印)</p>
<pre><code>D:\oc\code&gt;node vm0 sum.ob0
1+...+10=55</code></pre>
<p>也可以用加上 -d 參數的方式，傾印每一個指令的執行過程，如下所示：</p>
<p>虛擬機執行過程 (詳細傾印)</p>
<pre><code>D:\oc\code&gt;node vm0 sum.ob0 -d

00 :  001F003C 002F0034 0830000A 10230000
10 :  2300000C 13112000 1B220001 26FFFFEC
20 :  011F001C 012F0014 009F0022 2A000003
30 :  12910000 2A000004 2C000000 00000000
40 :  00000000 312B2E2E 2E2B3130 3D000000
50 :  0044
PC=0000 IR=001F003C SW=00000000 R[01]=0x00000000=0
PC=0004 IR=002F0034 SW=00000000 R[02]=0x00000000=0
PC=0008 IR=0830000A SW=00000000 R[03]=0x0000000A=10
PC=000C IR=10230000 SW=80000000 R[0C]=0x80000000=-2147483648
PC=0010 IR=2300000C SW=80000000 R[00]=0x00000000=0
PC=0014 IR=13112000 SW=80000000 R[01]=0x00000000=0
PC=0018 IR=1B220001 SW=80000000 R[02]=0x00000001=1
PC=001C IR=26FFFFEC SW=80000000 R[0F]=0x0000000C=12
PC=000C IR=10230000 SW=80000000 R[0C]=0x80000000=-2147483648
PC=0010 IR=2300000C SW=80000000 R[00]=0x00000000=0
PC=0014 IR=13112000 SW=80000000 R[01]=0x00000001=1
PC=0018 IR=1B220001 SW=80000000 R[02]=0x00000002=2
PC=001C IR=26FFFFEC SW=80000000 R[0F]=0x0000000C=12
PC=000C IR=10230000 SW=80000000 R[0C]=0x80000000=-2147483648
PC=0010 IR=2300000C SW=80000000 R[00]=0x00000000=0
PC=0014 IR=13112000 SW=80000000 R[01]=0x00000003=3
PC=0018 IR=1B220001 SW=80000000 R[02]=0x00000003=3
PC=001C IR=26FFFFEC SW=80000000 R[0F]=0x0000000C=12
PC=000C IR=10230000 SW=80000000 R[0C]=0x80000000=-2147483648
PC=0010 IR=2300000C SW=80000000 R[00]=0x00000000=0
PC=0014 IR=13112000 SW=80000000 R[01]=0x00000006=6
PC=0018 IR=1B220001 SW=80000000 R[02]=0x00000004=4
PC=001C IR=26FFFFEC SW=80000000 R[0F]=0x0000000C=12
PC=000C IR=10230000 SW=80000000 R[0C]=0x80000000=-2147483648
PC=0010 IR=2300000C SW=80000000 R[00]=0x00000000=0
PC=0014 IR=13112000 SW=80000000 R[01]=0x0000000A=10
PC=0018 IR=1B220001 SW=80000000 R[02]=0x00000005=5
PC=001C IR=26FFFFEC SW=80000000 R[0F]=0x0000000C=12
PC=000C IR=10230000 SW=80000000 R[0C]=0x80000000=-2147483648
PC=0010 IR=2300000C SW=80000000 R[00]=0x00000000=0
PC=0014 IR=13112000 SW=80000000 R[01]=0x0000000F=15
PC=0018 IR=1B220001 SW=80000000 R[02]=0x00000006=6
PC=001C IR=26FFFFEC SW=80000000 R[0F]=0x0000000C=12
PC=000C IR=10230000 SW=80000000 R[0C]=0x80000000=-2147483648
PC=0010 IR=2300000C SW=80000000 R[00]=0x00000000=0
PC=0014 IR=13112000 SW=80000000 R[01]=0x00000015=21
PC=0018 IR=1B220001 SW=80000000 R[02]=0x00000007=7
PC=001C IR=26FFFFEC SW=80000000 R[0F]=0x0000000C=12
PC=000C IR=10230000 SW=80000000 R[0C]=0x80000000=-2147483648
PC=0010 IR=2300000C SW=80000000 R[00]=0x00000000=0
PC=0014 IR=13112000 SW=80000000 R[01]=0x0000001C=28
PC=0018 IR=1B220001 SW=80000000 R[02]=0x00000008=8
PC=001C IR=26FFFFEC SW=80000000 R[0F]=0x0000000C=12
PC=000C IR=10230000 SW=80000000 R[0C]=0x80000000=-2147483648
PC=0010 IR=2300000C SW=80000000 R[00]=0x00000000=0
PC=0014 IR=13112000 SW=80000000 R[01]=0x00000024=36
PC=0018 IR=1B220001 SW=80000000 R[02]=0x00000009=9
PC=001C IR=26FFFFEC SW=80000000 R[0F]=0x0000000C=12
PC=000C IR=10230000 SW=80000000 R[0C]=0x80000000=-2147483648
PC=0010 IR=2300000C SW=80000000 R[00]=0x00000000=0
PC=0014 IR=13112000 SW=80000000 R[01]=0x0000002D=45
PC=0018 IR=1B220001 SW=80000000 R[02]=0x0000000A=10
PC=001C IR=26FFFFEC SW=80000000 R[0F]=0x0000000C=12
PC=000C IR=10230000 SW=40000000 R[0C]=0x40000000=1073741824
PC=0010 IR=2300000C SW=40000000 R[00]=0x00000000=0
PC=0014 IR=13112000 SW=40000000 R[01]=0x00000037=55
PC=0018 IR=1B220001 SW=40000000 R[02]=0x0000000B=11
PC=001C IR=26FFFFEC SW=40000000 R[0F]=0x0000000C=12
PC=000C IR=10230000 SW=00000000 R[0C]=0x00000000=0
PC=0010 IR=2300000C SW=00000000 R[00]=0x00000000=0
m[0040]=55
PC=0020 IR=011F001C SW=00000000 R[01]=0x00000037=55
m[003C]=11
PC=0024 IR=012F0014 SW=00000000 R[02]=0x0000000B=11
PC=0028 IR=009F0022 SW=00000000 R[09]=0x00000044=68
1+...+10=PC=002C IR=2A000003 SW=00000000 R[00]=0x00000000=0
PC=0030 IR=12910000 SW=00000000 R[09]=0x00000037=55
55PC=0034 IR=2A000004 SW=00000000 R[00]=0x00000000=0
PC=0038 IR=2C000000 SW=00000000 R[00]=0x00000000=0
</code></pre>
<p>如果您詳細追蹤上述過程，就能更清楚的看出每個指令執行時，所造成的暫存器變化，舉例而言，您可以看到程式 在 PC=000C 到 PC=001C 之間循環了很多次，最後一次的循環印出下列內容。</p>
<pre><code>PC=000C IR=10230000 SW=40000000 R[0C]=0x40000000=1073741824
PC=0010 IR=2300000C SW=40000000 R[00]=0x00000000=0
PC=0014 IR=13112000 SW=40000000 R[01]=0x00000037=55
PC=0018 IR=1B220001 SW=40000000 R[02]=0x0000000B=11
PC=001C IR=26FFFFEC SW=40000000 R[0F]=0x0000000C=12
PC=000C IR=10230000 SW=00000000 R[0C]=0x00000000=0
PC=0010 IR=2300000C SW=00000000 R[00]=0x00000000=0
m[0040]=55</code></pre>
<p>其中得到 R[01]=0x00000037=55 的計算結果，正是整個程式計算 1+2+...+10=55 的結果。</p>
<h3 id="vm0-虛擬機設計"><a href="#vm0-虛擬機設計">VM0 虛擬機設計</a></h3>
<p>接著、我們要來看看虛擬機 VM0 是如何設計的，但是在這之前，先讓我們看看虛擬機當中一個重要的資料結構， OpTable 指令表這個物件，其程式碼如下：</p>
<p>檔案：<a href="https://dl.dropboxusercontent.com/u/101584453/pmag/201309/code/oc/opTable.js">opTable.js</a></p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> c = <span class="fu">require</span>(<span class="st">&quot;./ccc&quot;</span>);

<span class="kw">var</span> Op = <span class="kw">function</span>(line) {
    <span class="kw">var</span> tokens = <span class="ot">line</span>.<span class="fu">split</span>(<span class="ot">/</span><span class="bn">\s</span><span class="fl">+</span><span class="ot">/</span>);
    <span class="kw">this</span>.<span class="fu">name</span> = tokens[<span class="dv">0</span>];
    <span class="kw">this</span>.<span class="fu">id</span>   = <span class="fu">parseInt</span>(tokens[<span class="dv">1</span>], <span class="dv">16</span>);
    <span class="kw">this</span>.<span class="fu">type</span> = tokens[<span class="dv">2</span>];
}

<span class="kw">var</span> opTable = <span class="kw">function</span>(opList) {
  <span class="kw">for</span> (i <span class="kw">in</span>  opList) {
    <span class="kw">var</span> op = <span class="kw">new</span> <span class="fu">Op</span>(opList[i]);
    <span class="kw">this</span>[<span class="ot">op</span>.<span class="fu">name</span>] = op;
  }  
}

<span class="ot">opTable</span>.<span class="ot">prototype</span>.<span class="fu">ID</span> = <span class="kw">function</span>(op) { 
  <span class="kw">return</span> <span class="kw">this</span>[op].<span class="fu">id</span>; 
}

<span class="ot">opTable</span>.<span class="ot">prototype</span>.<span class="fu">dump</span>=<span class="kw">function</span>() {
    <span class="kw">for</span> (key <span class="kw">in</span> <span class="kw">this</span>) {
      <span class="kw">var</span> op = <span class="kw">this</span>[key];
      <span class="kw">if</span> (<span class="kw">typeof</span>(op)!=<span class="st">&quot;function&quot;</span>)
        <span class="ot">c</span>.<span class="fu">log</span>(<span class="st">&quot;%s %s %s&quot;</span>, <span class="ot">c</span>.<span class="fu">fill</span>(<span class="st">&#39; &#39;</span>, <span class="ot">op</span>.<span class="fu">name</span>, <span class="dv">8</span>), <span class="ot">c</span>.<span class="fu">hex</span>(<span class="ot">op</span>.<span class="fu">id</span>, <span class="dv">2</span>), <span class="ot">op</span>.<span class="fu">type</span>);
    }
}

<span class="ot">module</span>.<span class="fu">exports</span> = opTable;</code></pre>
<p>然後、我們利用上述的 OpTable 模組，加入了 CPU0 的指令集之後，建出了 CPU0 這個代表處理器的模組， 程式碼如下。</p>
<p>檔案：<a href="https://dl.dropboxusercontent.com/u/101584453/pmag/201309/code/oc/cpu0.js">cpu0.js</a></p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> opTable = <span class="fu">require</span>(<span class="st">&quot;./optable&quot;</span>);
<span class="kw">var</span> opList = [ <span class="st">&quot;LD 00 L&quot;</span>, <span class="st">&quot;ST  01 L&quot;</span>, <span class="st">&quot;LDB 02 L&quot;</span>,  <span class="st">&quot;STB 03 L&quot;</span>, <span class="st">&quot;LDR 04 L&quot;</span>, 
<span class="st">&quot;STR 05 L&quot;</span>, <span class="st">&quot;LBR 06 L&quot;</span>,  <span class="st">&quot;SBR 07 L&quot;</span>,  <span class="st">&quot;LDI 08 L&quot;</span>, <span class="st">&quot;CMP 10 A&quot;</span>, <span class="st">&quot;MOV 12 A&quot;</span>, 
<span class="st">&quot;ADD 13 A&quot;</span>,  <span class="st">&quot;SUB 14 A&quot;</span>,  <span class="st">&quot;MUL 15 A&quot;</span>, <span class="st">&quot;DIV 16 A&quot;</span>,  <span class="st">&quot;AND 18 A&quot;</span>, <span class="st">&quot;OR  19 A&quot;</span>,  <span class="st">&quot;XOR 1A A&quot;</span>,  
<span class="st">&quot;ADDI 1B A&quot;</span>, <span class="st">&quot;ROL 1C A&quot;</span>,  <span class="st">&quot;ROR 1D A&quot;</span>, <span class="st">&quot;SHL 1E A&quot;</span>, <span class="st">&quot;SHR 1F A&quot;</span>,  
<span class="st">&quot;JEQ 20 J&quot;</span>, <span class="st">&quot;JNE 21 J&quot;</span>,  <span class="st">&quot;JLT 22 J&quot;</span>, <span class="st">&quot;JGT 23 J&quot;</span>, <span class="st">&quot;JLE 24 J&quot;</span>,  <span class="st">&quot;JGE 25 J&quot;</span>, <span class="st">&quot;JMP 26 J&quot;</span>, 
<span class="st">&quot;SWI 2A J&quot;</span>, <span class="st">&quot;JSUB 2B J&quot;</span>,<span class="st">&quot;RET 2C J&quot;</span>, <span class="st">&quot;PUSH 30 J&quot;</span>, <span class="st">&quot;POP 31 J&quot;</span>,  <span class="st">&quot;PUSHB 32 J&quot;</span>, 
<span class="st">&quot;POPB 33 J&quot;</span>, <span class="st">&quot;RESW F0 D&quot;</span>, <span class="st">&quot;RESB F1 D&quot;</span>, <span class="st">&quot;WORD F2 D&quot;</span>, <span class="st">&quot;BYTE F3 D&quot;</span>];

<span class="kw">var</span> cpu = { <span class="st">&quot;opTable&quot;</span> : <span class="kw">new</span> <span class="fu">opTable</span>(opList) };

<span class="kw">if</span> (<span class="ot">process</span>.<span class="fu">argv</span>[<span class="dv">2</span>] == <span class="st">&quot;-d&quot;</span>)
    <span class="ot">cpu</span>.<span class="ot">opTable</span>.<span class="fu">dump</span>();

<span class="ot">module</span>.<span class="fu">exports</span> = cpu;</code></pre>
<p>有了上述的兩個模組作為基礎，我們就可以開始撰寫虛擬機 VM0 了，以下是其原始程式碼。</p>
<p>檔案：<a href="https://dl.dropboxusercontent.com/u/101584453/pmag/201309/code/oc/vm0.js">vm0.js</a></p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> c = <span class="fu">require</span>(<span class="st">&quot;./ccc&quot;</span>);
<span class="kw">var</span> cpu1 = <span class="fu">require</span>(<span class="st">&quot;./cpu0&quot;</span>);
<span class="kw">var</span> Memory = <span class="fu">require</span>(<span class="st">&quot;./memory&quot;</span>);

<span class="kw">var</span> isDump = <span class="ot">process</span>.<span class="fu">argv</span>[<span class="dv">3</span>] == <span class="st">&quot;-d&quot;</span>;

<span class="kw">var</span> IR = <span class="dv">16</span>, PC = <span class="dv">15</span>, LR = <span class="dv">14</span>, SP = <span class="dv">13</span>, SW = <span class="dv">12</span>;
<span class="kw">var</span> ID = <span class="kw">function</span>(op) { <span class="kw">return</span> <span class="ot">cpu1</span>.<span class="fu">opTable</span>[op].<span class="fu">id</span>; }

<span class="kw">var</span> run = <span class="kw">function</span>(objFile) {
    R = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">10</span>, <span class="dv">11</span>, <span class="dv">0</span>, <span class="dv">13</span>, -<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">16</span>];
    m = <span class="kw">new</span> <span class="fu">Memory</span>(<span class="dv">1</span>);
    <span class="ot">m</span>.<span class="fu">load</span>(objFile);
    <span class="kw">if</span> (isDump) <span class="ot">m</span>.<span class="fu">dump</span>();
    <span class="kw">var</span> stop = <span class="kw">false</span>;
    <span class="kw">while</span> (!stop) {                                          <span class="co">// 如果尚未結束</span>
      <span class="kw">var</span> tpc = R[PC];
      R[<span class="dv">0</span>] = <span class="dv">0</span>;                                              <span class="co">// R[0] 永遠為 0</span>
      R[IR] = <span class="ot">m</span>.<span class="fu">geti</span>(R[PC]);                                 <span class="co">// 指令擷取，IR=[PC..PC+3]</span>
      R[PC] += <span class="dv">4</span>;                                            <span class="co">// 擷取完將 PC 加 4，指向下一個指令</span>
      <span class="kw">var</span> op = <span class="ot">c</span>.<span class="fu">bits</span>(R[IR], <span class="dv">24</span>, <span class="dv">31</span>);                        <span class="co">// 取得 op 欄位，IR[24..31]</span>
      <span class="kw">var</span> ra = <span class="ot">c</span>.<span class="fu">bits</span>(R[IR], <span class="dv">20</span>, <span class="dv">23</span>);                        <span class="co">// 取得 ra 欄位，IR[20..23]</span>
      <span class="kw">var</span> rb = <span class="ot">c</span>.<span class="fu">bits</span>(R[IR], <span class="dv">16</span>, <span class="dv">19</span>);                        <span class="co">// 取得 rb 欄位，IR[16..19]</span>
      <span class="kw">var</span> rc = <span class="ot">c</span>.<span class="fu">bits</span>(R[IR], <span class="dv">12</span>, <span class="dv">15</span>);                        <span class="co">// 取得 rc 欄位，IR[12..15]</span>
      <span class="kw">var</span> c24= <span class="ot">c</span>.<span class="fu">signbits</span>(R[IR], <span class="dv">0</span>,  <span class="dv">23</span>);                    <span class="co">// 取得 24 位元的 cx</span>
      <span class="kw">var</span> c16= <span class="ot">c</span>.<span class="fu">signbits</span>(R[IR], <span class="dv">0</span>,  <span class="dv">15</span>);                    <span class="co">// 取得 16 位元的 cx</span>
      <span class="kw">var</span> c5 = <span class="ot">c</span>.<span class="fu">bits</span>(R[IR], <span class="dv">0</span>,   <span class="dv">4</span>);                        <span class="co">// 取得 16 位元的 cx</span>
      <span class="kw">var</span> addr  = R[rb]+c16;
      <span class="kw">var</span> raddr = R[rb]+R[rc];                               <span class="co">// 取得位址[Rb+Rc]                          </span>
      <span class="kw">var</span> N  = <span class="ot">c</span>.<span class="fu">bits</span>(R[SW], <span class="dv">31</span>, <span class="dv">31</span>);
      <span class="kw">var</span> Z  = <span class="ot">c</span>.<span class="fu">bits</span>(R[SW], <span class="dv">30</span>, <span class="dv">30</span>);
<span class="co">//      c.log(&quot;IR=%s ra=%d rb=%d rc=%d c24=%s c16=%s addr=%s&quot;, c.hex(R[IR], 8), ra, rb, rc, c.hex(c24, 6), c.hex(c16, 4), c.hex(addr, 8))</span>
      <span class="kw">switch</span> (op) {                                          <span class="co">// 根據op執行動作</span>
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;LD&quot;</span>) : R[ra] = <span class="ot">m</span>.<span class="fu">geti</span>(addr); <span class="kw">break</span>;         <span class="co">// 處理 LD 指令</span>
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;ST&quot;</span>) :                                      <span class="co">// 處理 ST 指令</span>
          <span class="ot">m</span>.<span class="fu">seti</span>(addr, R[ra]); 
          <span class="kw">if</span> (isDump) <span class="ot">c</span>.<span class="fu">log</span>(<span class="st">&quot;m[%s]=%s&quot;</span>, <span class="ot">c</span>.<span class="fu">hex</span>(addr,<span class="dv">4</span>), <span class="ot">m</span>.<span class="fu">geti</span>(addr)); 
          <span class="kw">break</span>;
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;LDB&quot;</span>): R[ra] = <span class="ot">m</span>.<span class="fu">getb</span>(addr); <span class="kw">break</span>;         <span class="co">// 處理 LDB 指令</span>
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;STB&quot;</span>): <span class="ot">m</span>.<span class="fu">setb</span>(addr, R[ra]); <span class="kw">break</span>;          <span class="co">// 處理 STB 指令</span>
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;LDR&quot;</span>): R[ra] = <span class="ot">m</span>.<span class="fu">geti</span>(raddr); <span class="kw">break</span>;        <span class="co">// 處理 LDR 指令</span>
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;STR&quot;</span>): <span class="ot">m</span>.<span class="fu">seti</span>(raddr, R[ra]); <span class="kw">break</span>;         <span class="co">// 處理 STR 指令</span>
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;LBR&quot;</span>): R[ra] = <span class="ot">m</span>.<span class="fu">getb</span>(raddr); <span class="kw">break</span>;        <span class="co">// 處理 LBR 指令</span>
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;SBR&quot;</span>): <span class="ot">m</span>.<span class="fu">setb</span>(raddr, R[ra]); <span class="kw">break</span>;         <span class="co">// 處理 SBR 指令</span>
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;LDI&quot;</span>): R[ra] = c16; <span class="kw">break</span>;                  <span class="co">// 處理 LDI 指令</span>
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;CMP&quot;</span>): {                                    <span class="co">// 處理 CMP指令，根據比較結果，設定 N,Z 旗標 </span>
          <span class="kw">if</span> (R[ra] &gt; R[rb]) {                               <span class="co">// &gt; : SW(N=0, Z=0)</span>
            R[SW] &amp;= <span class="bn">0x3FFFFFFF</span>;                             <span class="co">// N=0, Z=0</span>
          } <span class="kw">else</span> <span class="kw">if</span> (R[ra] &lt; R[rb]) {                        <span class="co">// &lt; : SW(N=1, Z=0, ....)                                                </span>
            R[SW] |= <span class="bn">0x80000000</span>;                             <span class="co">// N=1;</span>
            R[SW] &amp;= <span class="bn">0xBFFFFFFF</span>;                             <span class="co">// Z=0;</span>
          } <span class="kw">else</span> {                                           <span class="co">// = : SW(N=0, Z=1)                      </span>
            R[SW] &amp;= <span class="bn">0x7FFFFFFF</span>;                             <span class="co">// N=0;</span>
            R[SW] |= <span class="bn">0x40000000</span>;                             <span class="co">// Z=1;</span>
          }
          ra = <span class="dv">12</span>;
          <span class="kw">break</span>;                                                                                        
        }
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;MOV&quot;</span>): R[ra] = R[rb]; <span class="kw">break</span>;                <span class="co">// 處理MOV指令</span>
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;ADD&quot;</span>): R[ra] = R[rb]+R[rc]; <span class="kw">break</span>;          <span class="co">// 處理ADD指令</span>
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;SUB&quot;</span>): R[ra] = R[rb]-R[rc]; <span class="kw">break</span>;          <span class="co">// 處理SUB指令</span>
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;MUL&quot;</span>): R[ra] = R[rb]*R[rc]; <span class="kw">break</span>;          <span class="co">// 處理MUL指令</span>
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;DIV&quot;</span>): R[ra] = R[rb]/R[rc]; <span class="kw">break</span>;          <span class="co">// 處理DIV指令</span>
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;AND&quot;</span>): R[ra] = R[rb]&amp;R[rc]; <span class="kw">break</span>;          <span class="co">// 處理AND指令</span>
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;OR&quot;</span>) : R[ra] = R[rb]|R[rc]; <span class="kw">break</span>;          <span class="co">// 處理OR指令</span>
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;XOR&quot;</span>): R[ra] = R[rb]^R[rc]; <span class="kw">break</span>;          <span class="co">// 處理XOR指令</span>
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;SHL&quot;</span>): R[ra] = R[rb]&lt;&lt;c5; <span class="kw">break</span>;            <span class="co">// 處理SHL指令</span>
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;SHR&quot;</span>): R[ra] = R[rb]&gt;&gt;c5; <span class="kw">break</span>;            <span class="co">// 處理SHR指令</span>
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;ADDI&quot;</span>):R[ra] = R[rb] + c16; <span class="kw">break</span>;          <span class="co">// 處理 ADDI 指令</span>
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;JEQ&quot;</span>): <span class="kw">if</span> (Z==<span class="dv">1</span>) R[PC] += c24; <span class="kw">break</span>;       <span class="co">// 處理JEQ指令 Z=1</span>
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;JNE&quot;</span>): <span class="kw">if</span> (Z==<span class="dv">0</span>) R[PC] += c24; <span class="kw">break</span>;       <span class="co">// 處理JNE指令 Z=0 </span>
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;JLT&quot;</span>): <span class="kw">if</span> (N==<span class="dv">1</span>&amp;&amp;Z==<span class="dv">0</span>) R[PC] += c24; <span class="kw">break</span>; <span class="co">// 處理JLT指令 NZ=10 </span>
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;JGT&quot;</span>): <span class="kw">if</span> (N==<span class="dv">0</span>&amp;&amp;Z==<span class="dv">0</span>) R[PC] += c24; <span class="kw">break</span>; <span class="co">// 處理JGT指令 NZ=00</span>
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;JLE&quot;</span>): <span class="kw">if</span> ((N==<span class="dv">1</span>&amp;&amp;Z==<span class="dv">0</span>)||(N==<span class="dv">0</span>&amp;&amp;Z==<span class="dv">1</span>)) R[PC]+=c24; <span class="kw">break</span>; <span class="co">// 處理JLE指令 NZ=10 or 01</span>
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;JGE&quot;</span>): <span class="kw">if</span> ((N==<span class="dv">0</span>&amp;&amp;Z==<span class="dv">0</span>)||(N==<span class="dv">0</span>&amp;&amp;Z==<span class="dv">1</span>)) R[PC]+=c24; <span class="kw">break</span>; <span class="co">// 處理JGE指令 NZ=00 or 01</span>
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;JMP&quot;</span>): R[PC]+=c24; <span class="kw">break</span>;                   <span class="co">// 處理JMP指令                             </span>
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;SWI&quot;</span>):                                      <span class="co">// 處理SWI指令</span>
            <span class="kw">switch</span> (c24) {
                <span class="kw">case</span> <span class="dv">3</span>: <span class="ot">c</span>.<span class="fu">printf</span>(<span class="st">&quot;%s&quot;</span>, <span class="ot">m</span>.<span class="fu">getstr</span>(R[<span class="dv">9</span>])); <span class="kw">break</span>;
                <span class="kw">case</span> <span class="dv">4</span>: <span class="ot">c</span>.<span class="fu">printf</span>(<span class="st">&quot;%d&quot;</span>, R[<span class="dv">9</span>]); <span class="kw">break</span>;
                <span class="kw">default</span>: 
                    <span class="kw">var</span> emsg = <span class="ot">c</span>.<span class="fu">format</span>(<span class="st">&quot;SWI cx=%d not found!&quot;</span>, c24); 
                    <span class="ot">c</span>.<span class="fu">error</span>(emsg, <span class="kw">null</span>); 
                    <span class="kw">break</span>;
            }
            <span class="kw">break</span>;
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;JSUB&quot;</span>):R[LR] = R[PC]; R[PC]+=c24; <span class="kw">break</span>;    <span class="co">// 處理JSUB指令</span>
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;RET&quot;</span>): <span class="kw">if</span> (R[LR]&lt;<span class="dv">0</span>) stop=<span class="kw">true</span>; <span class="kw">else</span> R[PC]=LR; <span class="kw">break</span>; <span class="co">// 處理RET指令</span>
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;PUSH&quot;</span>):R[SP]-=<span class="dv">4</span>; R[ra]=<span class="ot">m</span>.<span class="fu">geti</span>(addr); <span class="ot">m</span>.<span class="fu">seti</span>(R[SP], R[ra]); <span class="kw">break</span>; <span class="co">// 處理PUSH指令</span>
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;POP&quot;</span>): R[ra] = <span class="ot">m</span>.<span class="fu">geti</span>(R[SP]); R[SP]+=<span class="dv">4</span>; <span class="kw">break</span>;     <span class="co">// 處理POP指令</span>
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;PUSHB&quot;</span>):R[SP]--; R[ra]=<span class="ot">m</span>.<span class="fu">getb</span>(addr); <span class="ot">m</span>.<span class="fu">setb</span>(R[SP], R[ra]); <span class="kw">break</span>; <span class="co">// 處理PUSH指令</span>
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;POPB&quot;</span>):R[ra] = <span class="ot">m</span>.<span class="fu">getb</span>(R[SP]); R[SP]++; <span class="kw">break</span>;      <span class="co">// 處理POPB指令</span>
        <span class="kw">default</span>: <span class="ot">c</span>.<span class="fu">error</span>(<span class="st">&quot;OP not found!&quot;</span>, <span class="kw">null</span>);
      } <span class="co">// switch</span>
      <span class="kw">if</span> (isDump) 
        <span class="ot">c</span>.<span class="fu">log</span>(<span class="st">&quot;PC=%s IR=%s SW=%s R[%s]=0x%s=%d&quot;</span>, <span class="co">// 印出 PC, IR, R[ra]暫存器的值，以利觀察</span>
              <span class="ot">c</span>.<span class="fu">hex</span>(tpc,<span class="dv">4</span>), <span class="ot">c</span>.<span class="fu">hex</span>(R[IR],<span class="dv">8</span>), <span class="ot">c</span>.<span class="fu">hex</span>(R[SW],<span class="dv">8</span>), <span class="ot">c</span>.<span class="fu">hex</span>(ra,<span class="dv">2</span>), <span class="ot">c</span>.<span class="fu">hex</span>(R[ra], <span class="dv">8</span>), R[ra]);
    } <span class="co">// while</span>
}

<span class="fu">run</span>(<span class="ot">process</span>.<span class="fu">argv</span>[<span class="dv">2</span>]);</code></pre>
<p>從上面的 VM0 虛擬機當中，您可以看到，假如不考慮執行速度的問題，那麼要撰寫一個虛擬機是非常容易的事情。 我們只要去忠實的模擬每一個指令所應該做的動作，就可以完成虛擬機的設計了。</p>
<p>讓我們稍微解釋一下上述 VM0 虛擬機的程式原理，請讀者將焦點先放在以下的程式片段中。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">    ...
    <span class="fu">m</span> = <span class="kw">new</span> <span class="fu">Memory</span>(<span class="dv">1</span>);
    <span class="ot">m</span>.<span class="fu">load</span>(objFile);
    <span class="kw">var</span> stop = <span class="kw">false</span>;
    <span class="kw">while</span> (!stop) {                                          <span class="co">// 如果尚未結束</span>
      ...
      <span class="fu">R</span>[IR] = <span class="ot">m</span>.<span class="fu">geti</span>(R[PC]);                                 <span class="co">// 指令擷取，IR=[PC..PC+3]</span>
      R[PC] += <span class="dv">4</span>;                                            <span class="co">// 擷取完將 PC 加 4，指向下一個指令</span>
      <span class="kw">var</span> op = <span class="ot">c</span>.<span class="fu">bits</span>(R[IR], <span class="dv">24</span>, <span class="dv">31</span>);                        <span class="co">// 取得 op 欄位，IR[24..31]</span>
      <span class="kw">var</span> ra = <span class="ot">c</span>.<span class="fu">bits</span>(R[IR], <span class="dv">20</span>, <span class="dv">23</span>);                        <span class="co">// 取得 ra 欄位，IR[20..23]</span>
      <span class="kw">var</span> rb = <span class="ot">c</span>.<span class="fu">bits</span>(R[IR], <span class="dv">16</span>, <span class="dv">19</span>);                        <span class="co">// 取得 rb 欄位，IR[16..19]</span>
      <span class="kw">var</span> rc = <span class="ot">c</span>.<span class="fu">bits</span>(R[IR], <span class="dv">12</span>, <span class="dv">15</span>);                        <span class="co">// 取得 rc 欄位，IR[12..15]</span>
      <span class="kw">var</span> c24= <span class="ot">c</span>.<span class="fu">signbits</span>(R[IR], <span class="dv">0</span>,  <span class="dv">23</span>);                    <span class="co">// 取得 24 位元的 cx</span>
      <span class="kw">var</span> c16= <span class="ot">c</span>.<span class="fu">signbits</span>(R[IR], <span class="dv">0</span>,  <span class="dv">15</span>);                    <span class="co">// 取得 16 位元的 cx</span>
      <span class="kw">var</span> c5 = <span class="ot">c</span>.<span class="fu">bits</span>(R[IR], <span class="dv">0</span>,   <span class="dv">4</span>);                        <span class="co">// 取得 16 位元的 cx</span>
      <span class="kw">var</span> addr  = R[rb]+c16;
      <span class="kw">var</span> raddr = R[rb]+R[rc];                               <span class="co">// 取得位址[Rb+Rc]                          </span>
      <span class="kw">var</span> N  = <span class="ot">c</span>.<span class="fu">bits</span>(R[SW], <span class="dv">31</span>, <span class="dv">31</span>);
      <span class="kw">var</span> Z  = <span class="ot">c</span>.<span class="fu">bits</span>(R[SW], <span class="dv">30</span>, <span class="dv">30</span>);
      <span class="kw">switch</span> (op) {                                          <span class="co">// 根據op執行動作</span>
        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;LD&quot;</span>) : R[ra] = <span class="ot">m</span>.<span class="fu">geti</span>(addr); <span class="kw">break</span>;         <span class="co">// 處理 LD 指令</span>
        ...
        <span class="fu">case</span> <span class="fu">ID</span>(<span class="st">&quot;JMP&quot;</span>): R[PC]+=c24; <span class="kw">break</span>;                   <span class="co">// 處理JMP指令                             </span>
        ...
        <span class="fu">case</span> <span class="fu">ID</span>(<span class="st">&quot;JSUB&quot;</span>):R[LR] = R[PC]; R[PC]+=c24; <span class="kw">break</span>;    <span class="co">// 處理JSUB指令</span>
        ...
        <span class="fu">case</span> <span class="fu">ID</span>(<span class="st">&quot;RET&quot;</span>): <span class="kw">if</span> (R[LR]&lt;<span class="dv">0</span>) stop=<span class="kw">true</span>; <span class="kw">else</span> R[PC]=LR; <span class="kw">break</span>; <span class="co">// 處理RET指令</span>
        ...        </code></pre>
<p>首先我們用 m = new Memory(1) 建立一個空的記憶體，然後再用 m.load(objFile) 載入目的檔到記憶體中， 接著就開始進入 while (!stop) 起頭的指令解譯迴圈了，然後接著用 R[IR] = m.geti(R[PC]) 這個指令取出 程式計數暫存器 PC 所指到的記憶體內容 m[PC]，然後放到指令暫存器 IR 當中，接著就可以取出指令暫存器 IR 當中的欄位，像是指令碼 op、暫存器 ra, rb, rc 與常數部分 c24, c16, c5 等欄位。</p>
<p>然後就能對每個指令所應做的動作進行模擬，例如 LD 指令的功能是將記憶體位址 addr = R[rb]+c16 的內容 取出，放到編號 ra 的暫存器當中，因此只要用 R[ra] = m.geti(addr) 這樣一個函數呼叫，就可以完成模擬的動作了。</p>
<p>當然、有些模擬動作很簡單，可以用一兩個指令做完，像是 LD, ST, JMP 等都是如此，但有些動作就比較複雜， 像是 JSUB, RET, PUSH, POP 等就要好幾個指令，最複雜的大概是 CMP 與 SWI 這兩個指令了，CMP 由於牽涉到比較動作 且需要設定 N, Z 等旗標，所以程式碼較長如下：</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">...
        <span class="fu">case</span> <span class="fu">ID</span>(<span class="st">&quot;CMP&quot;</span>): {                                    <span class="co">// 處理 CMP指令，根據比較結果，設定 N,Z 旗標 </span>
          <span class="kw">if</span> (R[ra] &gt; R[rb]) {                               <span class="co">// &gt; : SW(N=0, Z=0)</span>
            R[SW] &amp;= <span class="bn">0x3FFFFFFF</span>;                             <span class="co">// N=0, Z=0</span>
          } <span class="kw">else</span> <span class="kw">if</span> (R[ra] &lt; R[rb]) {                        <span class="co">// &lt; : SW(N=1, Z=0, ....)                                                </span>
            R[SW] |= <span class="bn">0x80000000</span>;                             <span class="co">// N=1;</span>
            R[SW] &amp;= <span class="bn">0xBFFFFFFF</span>;                             <span class="co">// Z=0;</span>
          } <span class="kw">else</span> {                                           <span class="co">// = : SW(N=0, Z=1)                      </span>
            R[SW] &amp;= <span class="bn">0x7FFFFFFF</span>;                             <span class="co">// N=0;</span>
            R[SW] |= <span class="bn">0x40000000</span>;                             <span class="co">// Z=1;</span>
          }
          ra = <span class="dv">12</span>;
          <span class="kw">break</span>;                                                                                        
        }
...</code></pre>
<p>而 SWI 則是軟體中斷，這個部分也可以不做任何事，不過如果要支援某些中斷函數的話，就可以在這個指令中進行模擬， 目前 SWI 指令處理的原始碼如下：</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">        <span class="kw">case</span> <span class="fu">ID</span>(<span class="st">&quot;SWI&quot;</span>):                                      <span class="co">// 處理SWI指令</span>
            <span class="kw">switch</span> (c24) {
                <span class="kw">case</span> <span class="dv">3</span>: <span class="ot">c</span>.<span class="fu">printf</span>(<span class="st">&quot;%s&quot;</span>, <span class="ot">m</span>.<span class="fu">getstr</span>(R[<span class="dv">9</span>])); <span class="kw">break</span>;
                <span class="kw">case</span> <span class="dv">4</span>: <span class="ot">c</span>.<span class="fu">printf</span>(<span class="st">&quot;%d&quot;</span>, R[<span class="dv">9</span>]); <span class="kw">break</span>;
                <span class="kw">default</span>: 
                    <span class="kw">var</span> emsg = <span class="ot">c</span>.<span class="fu">format</span>(<span class="st">&quot;SWI cx=%d not found!&quot;</span>, c24); 
                    <span class="ot">c</span>.<span class="fu">error</span>(emsg, <span class="kw">null</span>); 
                    <span class="kw">break</span>;
            }
            <span class="kw">break</span>;</code></pre>
<p>目前我們支援兩個中斷處理呼叫，也就是 SWI 3 與 SWI 4。</p>
<p>其中的 SWI 4 會在螢幕上印出一個儲存在暫存器 R[9] 當中的整數，而 SWI 3 會在螢幕上印出一個記憶體當中的字串， 這個字串的起始位址也是儲存在暫存器 R[9] 當中的。</p>
<h3 id="結語"><a href="#結語">結語</a></h3>
<p>透過 VM0，筆者希望能夠讓讀者清楚的瞭解虛擬機的設計方式，當然、VM0 是一個「跑得很慢」的虛擬機。</p>
<p>如果要讓虛擬機跑得很快，通常要搭配「立即編譯技術」(Just in Time Compiler, JIT) ，像是 Java 虛擬機 JVM 就是利用 JIT 才能夠讓 Java 程式跑得夠快，而 QEMU 則是機器碼反編譯為 C 語言基本運算後，再度用 gcc 編譯 為機器碼，才能達到高速執行的目的。</p>
<p>而另外、像是 VMWare、VirtualBox 等，則是在相同的 x86 架構下去執行的，因此重點變成「如何有效的繞過作業系統 的控管，讓機器碼在 CPU 上執行」的問題了。</p>
<p>瞭解了 VM0 虛擬機之後，我們就要進入開放電腦計畫的另一個部分，CPU 的硬體設計了，這就不再是用 JavaScript 這樣 的高階語言去模擬 CPU 的行為了，而是直接用硬體描述語言 Verilog 來設計一顆 CPU。</p>
<p>當然、我們設計的 CPU 仍然是 CPU0，不過卻是用 Verilog 設計的 CPU0，可以被燒錄到 FPGA 上去執行，成為真正的硬體。</p>
<p>在這幾期的程式人雜誌中，我們已經開始介紹了 Verilog 語言，其目的也正是在為設計 Verilog 版的 CPU0 而鋪路， 有興趣的朋友們可以先看看這幾期的 Verilog 語言介紹，這樣就比較能在下期的「程式人雜誌」中，看懂如何用 Verilog 設計 CPU 了，以下是這幾期的 Verilog 相關文章列表。</p>
<ul>
<li><a href="https://dl.dropboxusercontent.com/u/101584453/pmag/201306/htm/article4.html">Verilog (1) – 以 Icarus 測試全加器</a></li>
<li><a href="http://programmermagazine.github.io/201307/htm/article4.html">Verilog (2) – 硬體語言的基礎</a></li>
<li><a href="https://dl.dropboxusercontent.com/u/101584453/pmag/201306/htm/article4.html">Verilog (3) – 組合邏輯電路</a></li>
</ul>
<p>當然、這短短幾篇文章無法完整的介紹 Verilog 的功能，另外再提供筆者先前的網誌給大家參考。</p>
<ul>
<li><a href="http://ccckmit.wikidot.com/ve:main">免費電子書：Verilog 電路設計</a>, 陳鍾誠的網站。</li>
<li><a href="http://ccckmit.wikidot.com/co:main">計算機結構 -- 實務取向</a>, 陳鍾誠的網站。</li>
</ul>
<p>這學期，筆者也將開設一門「計算機結構」的課程，筆者最近努力為每一門課都寫一本電子書，這門課也不例外，而且 正是採用以 CPU0 為核心的寫法。雖然還沒完成，但裏面已經包含了上次開課時所做的教學錄影，或許讀者會有興趣， 在此一並提供給讀者參考。</p>
<ul>
<li><a href="https://dl.dropboxusercontent.com/u/101584453/oc/htm/book.html">電子書：計算機軟硬體結構</a>, 開放電腦計畫 -- 陳鍾誠。</li>
</ul>
</div>
<div id="footer">
<a href="https://www.facebook.com/groups/programmerMagazine/">程式人雜誌</a> ，採用 <a href="http://creativecommons.org/licenses/by-sa/3.0/tw/ ">創作共用：姓名標示、相同方式分享</a> 授權，歡迎加入 <a href="https://www.facebook.com/groups/programmerMagazine/">雜誌社團</a>
</div>
</body>
</html>
